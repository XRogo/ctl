<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa z Warstwami PNG i WebP</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000;
        }
        #map-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            background-color: #000;
        }
        #map {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
        }
        #zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        #zoom-controls button {
            display: block;
            margin: 5px;
            padding: 10px;
            font-size: 20px;
            background-color: #444;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #zoom-controls button:hover {
            background-color: #666;
        }
        #category-controls {
            position: absolute;
            top: 70px;
            right: 10px;
            z-index: 10;
        }
        #category-controls button {
            display: block;
            margin: 5px;
            padding: 8px;
            font-size: 16px;
            background-color: #444;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #category-controls button:hover {
            background-color: #666;
        }
        #category-controls button.active {
            background-color: #007bff;
        }
        #toggle-webp {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            padding: 10px;
            font-size: 20px;
            background-color: #444;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #toggle-webp:hover {
            background-color: #666;
        }
        #zoom-display {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 5px 10px;
            font-size: 16px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-family: Arial, sans-serif;
        }
        #coord-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            padding: 5px 10px;
            font-size: 16px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 4px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <canvas id="map"></canvas>
    </div>
    <div id="zoom-controls">
        <button id="zoom-in">+</button>
        <button id="zoom-out">-</button>
    </div>
    <div id="category-controls">
        <!-- Przyciski kategorii bÄ™dÄ… generowane dynamicznie -->
    </div>
    <button id="toggle-webp">ðŸ”’</button>
    <div id="zoom-display">Zoom: 1.0x</div>
    <div id="coord-display">X: 0, Z: 0</div>

    <script>
        const PNG_SIZE = 2000;
        const WEBP_SIZE = 7612;
        const imagePath = 'kafelki/';
        const tiles = ['0,0', '0,-0', '-0,0', '-0,-0'];
        const minZoom = 0.1;
        const maxZoom = 50;

        function parseCoord(str, isWebP = false) {
            const size = isWebP ? WEBP_SIZE : PNG_SIZE;
            if (str === '0') return 0;
            if (str === '-0') return -size;
            return parseInt(str, 10) > 0 ? parseInt(str, 10) * size : (parseInt(str, 10) - 1) * size;
        }

        function getTileKey(x, y) {
            return `${x},${y}`;
        }

        function calculateCentroid(points) {
            let xSum = 0, zSum = 0;
            points.forEach(([x, z]) => {
                xSum += x;
                zSum += z;
            });
            const count = points.length;
            return count > 0 ? [xSum / count, zSum / count] : [0, 0];
        }

        class TileMap {
            constructor(container) {
                this.container = container;
                this.canvas = document.getElementById('map');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.mozImageSmoothingEnabled = false;
                this.ctx.webkitImageSmoothingEnabled = false;
                this.ctx.msImageSmoothingEnabled = false;
                this.ctx.imageSmoothingQuality = 'low';
                this.images = { png: new Map(), webp: new Map() };
                this.loadWebPEnabled = false;
                this.zoom = 1;
                this.posX = 0;
                this.posY = 0;
                this.dragging = false;
                this.startX = 0;
                this.startY = 0;
                this.needsRedraw = true;
                this.lastPosX = 0;
                this.lastPosY = 0;
                this.lastZoom = 1;
                this.zoomDisplay = document.getElementById('zoom-display');
                this.coordDisplay = document.getElementById('coord-display');
                this.polygons = [];
                this.visibleCategories = {};
                this.ctrlPressed = false;

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.loadImages();
                this.loadPositions();

                this.toggleButton = document.getElementById('toggle-webp');
                this.toggleButton.addEventListener('click', () => this.toggleWebP());

                this.setupEvents();

                requestAnimationFrame(() => this.render());
            }

            loadImages() {
                tiles.forEach(key => {
                    const [x, y] = key.split(',');
                    const img = new Image();
                    img.src = `${imagePath}${key}.png`;
                    img.onload = () => {
                        this.needsRedraw = true;
                        this.render();
                    };
                    img.onerror = () => {
                        console.error(`Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ ${img.src}`);
                    };
                    this.images.png.set(key, img);
                });
            }

            loadWebP() {
                if (this.loadWebPEnabled) {
                    const loadWebPSequentially = (index = 0) => {
                        if (index >= tiles.length) {
                            this.needsRedraw = true;
                            this.render();
                            return;
                        }
                        const key = tiles[index];
                        const [x, y] = key.split(',');
                        const img = new Image();
                        img.src = `${imagePath}${key}.webp`;
                        img.onload = () => {
                            this.images.webp.set(key, img);
                            this.needsRedraw = true;
                            this.render();
                            loadWebPSequentially(index + 1);
                        };
                        img.onerror = () => {
                            console.error(`Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ ${img.src}`);
                            loadWebPSequentially(index + 1);
                        };
                    };
                    loadWebPSequentially();
                }
            }

            async loadPositions() {
                try {
                    const response = await fetch('pozycje.js');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const text = await response.text();
                    let polygons = [];
                    eval(text);
                    this.polygons = polygons || [];
                    console.log('Loaded polygons:', this.polygons);

                    // Inicjalizuj widocznoÅ›Ä‡ kategorii
                    this.polygons.forEach(polygon => {
                        if (polygon.category && this.visibleCategories[polygon.category] === undefined) {
                            this.visibleCategories[polygon.category] = true;
                        }
                    });
                    this.updateCategoryControls();

                    // Wycentruj na pierwszym poligonie, jeÅ›li istnieje
                    if (this.polygons.length > 0 && this.polygons[0].points.length > 0) {
                        const [centerX, centerZ] = calculateCentroid(this.polygons[0].points);
                        this.posX = this.canvas.width / 2 - centerX * this.zoom;
                        this.posY = this.canvas.height / 2 - centerZ * this.zoom;
                        this.lastPosX = this.posX;
                        this.lastPosY = this.posY;
                        this.coordDisplay.textContent = `X: ${Math.round(centerX)}, Z: ${Math.round(centerZ)}`;
                    } else {
                        this.centerOnStyk();
                    }

                    this.needsRedraw = true;
                    this.render();
                } catch (e) {
                    console.error('Nie udaÅ‚o siÄ™ zaÅ‚adowaÄ‡ pozycje.js', e);
                }
            }

            updateCategoryControls() {
                const categoryControls = document.getElementById('category-controls');
                categoryControls.innerHTML = '';
                Object.keys(this.visibleCategories).forEach(category => {
                    const button = document.createElement('button');
                    button.textContent = `Toggle Category ${category}`;
                    button.className = this.visibleCategories[category] ? 'active' : '';
                    button.addEventListener('click', () => {
                        this.visibleCategories[category] = !this.visibleCategories[category];
                        button.className = this.visibleCategories[category] ? 'active' : '';
                        this.needsRedraw = true;
                        this.render();
                    });
                    categoryControls.appendChild(button);
                });
            }

            toggleWebP() {
                if (!this.loadWebPEnabled) {
                    const confirmLoad = confirm("WÅ‚Ä…czenie tej funkcji pozwoli wyÅ›wietliÄ‡ caÅ‚Ä… mapÄ™, ale strona bÄ™dzie bardzo zasoborzerna");
                    if (confirmLoad) {
                        this.loadWebPEnabled = true;
                        this.toggleButton.textContent = 'ðŸ”“';
                        this.loadWebP();
                    }
                } else {
                    this.loadWebPEnabled = false;
                    this.toggleButton.textContent = 'ðŸ”’';
                    this.images.webp.clear();
                    this.needsRedraw = true;
                    this.render();
                    if (window.gc) window.gc();
                }
            }

            resizeCanvas() {
                const pixelRatio = window.devicePixelRatio || 1;
                this.canvas.width = window.innerWidth * pixelRatio;
                this.canvas.height = window.innerHeight * pixelRatio;
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.imageSmoothingQuality = 'low';
                this.needsRedraw = true;
            }

            centerOnStyk() {
                this.posX = this.canvas.width / 2;
                this.posY = this.canvas.height / 2;
                this.lastPosX = this.posX;
                this.lastPosY = this.posY;
                this.coordDisplay.textContent = `X: 0, Z: 0`;
            }

            setupEvents() {
                const zoomInBtn = document.getElementById('zoom-in');
                const zoomOutBtn = document.getElementById('zoom-out');

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Control') {
                        this.ctrlPressed = true;
                        console.log('Ctrl pressed:', this.ctrlPressed);
                    }
                });
                document.addEventListener('keyup', (e) => {
                    if (e.key === 'Control') {
                        this.ctrlPressed = false;
                        console.log('Ctrl released:', this.ctrlPressed);
                    }
                });

                zoomInBtn.addEventListener('click', () => {
                    const delta = this.ctrlPressed ? 1 : 0.1;
                    this.setZoom(this.zoom + delta);
                });

                zoomOutBtn.addEventListener('click', () => {
                    const delta = this.ctrlPressed ? 1 : 0.1;
                    this.setZoom(this.zoom - delta);
                });

                this.container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const delta = e.deltaY < 0 ? 1 : -1;
                    const zoomDelta = this.ctrlPressed ? delta : delta * 0.1;
                    this.setZoom(this.zoom + zoomDelta, mouseX, mouseY);
                });

                this.container.addEventListener('mousedown', (e) => {
                    this.dragging = true;
                    this.startX = e.clientX;
                    this.startY = e.clientY;
                    this.container.style.cursor = 'grabbing';
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.dragging) {
                        this.posX += e.clientX - this.startX;
                        this.startX = e.clientX;
                        this.posY += e.clientY - this.startY;
                        this.startY = e.clientY;
                        this.clampPosition();
                        this.needsRedraw = true;
                    }
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const worldX = Math.round((mouseX - this.posX) / this.zoom);
                    const worldZ = Math.round((mouseY - this.posY) / this.zoom);
                    this.coordDisplay.textContent = `X: ${worldX}, Z: ${worldZ}`;
                });

                document.addEventListener('mouseup', () => {
                    this.dragging = false;
                    this.container.style.cursor = 'grab';
                });
            }

            setZoom(newZoom, centerX = this.canvas.width / 2, centerY = this.canvas.height / 2) {
                newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
                const worldX = (centerX - this.posX) / this.zoom;
                const worldY = (centerY - this.posY) / this.zoom;
                this.zoom = newZoom;
                this.posX = centerX - worldX * this.zoom;
                this.posY = centerY - worldY * this.zoom;
                this.clampPosition();
                this.needsRedraw = true;
                this.zoomDisplay.textContent = `Zoom: ${this.zoom.toFixed(1)}x`;
                console.log(`Zoom set to: ${this.zoom}`);
            }

            getMapBounds() {
                let minX = 0, maxX = 0, minY = 0, maxY = 0;
                tiles.forEach(key => {
                    const [x, y] = key.split(',');
                    const posX = parseCoord(x, this.loadWebPEnabled);
                    const posY = parseCoord(y, this.loadWebPEnabled);
                    const size = this.loadWebPEnabled ? WEBP_SIZE : PNG_SIZE;
                    minX = Math.min(minX, posX);
                    maxX = Math.max(maxX, posX + size);
                    minY = Math.min(minY, posY);
                    maxY = Math.max(maxY, posY + size);
                });
                return { minX, maxX, minY, maxY };
            }

            clampPosition() {
                const { minX, maxX, minY, maxY } = this.getMapBounds();
                const viewWidth = this.canvas.width / this.zoom;
                const viewHeight = this.canvas.height / this.zoom;
                const minPosX = -(maxX * this.zoom - 1);
                const maxPosX = this.canvas.width - (minX * this.zoom + 1);
                const minPosY = -(maxY * this.zoom - 1);
                const maxPosY = this.canvas.height - (minY * this.zoom + 1);
                this.posX = Math.max(minPosX, Math.min(maxPosX, this.posX));
                this.posY = Math.max(minPosY, Math.min(maxPosY, this.posY));
            }

            isVisible(x, y, width, height) {
                const viewWidth = this.canvas.width / this.zoom;
                const viewHeight = this.canvas.height / this.zoom;
                const viewLeft = -this.posX / this.zoom;
                const viewRight = viewLeft + viewWidth;
                const viewTop = -this.posY / this.zoom;
                const viewBottom = viewTop + viewHeight;
                return x < viewRight && x + width > viewLeft && y < viewBottom && y + height > viewTop;
            }

            render() {
                if (!this.needsRedraw && this.posX === this.lastPosX && this.posY === this.lastPosY && this.zoom === this.lastZoom) {
                    requestAnimationFrame(() => this.render());
                    return;
                }

                const renderStart = performance.now();
                this.needsRedraw = false;
                this.lastPosX = this.posX;
                this.lastPosY = this.posY;
                this.lastZoom = this.zoom;

                const pixelRatio = window.devicePixelRatio || 1;
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                const pixelPerfectX = Math.round(this.posX * pixelRatio) / pixelRatio;
                const pixelPerfectY = Math.round(this.posY * pixelRatio) / pixelRatio;
                this.ctx.translate(pixelPerfectX, pixelPerfectY);
                this.ctx.scale(this.zoom, this.zoom);
                this.ctx.imageSmoothingEnabled = false;
                this.ctx.imageSmoothingQuality = 'low';

                console.log(`Rendering: posX=${pixelPerfectX}, posY=${pixelPerfectY}, zoom=${this.zoom}, pixelRatio=${pixelRatio}`);

                let webpCount = 0;
                if (this.loadWebPEnabled) {
                    tiles.forEach(key => {
                        const [x, y] = key.split(',');
                        const img = this.images.webp.get(key);
                        const posX = parseCoord(x, true);
                        const posY = parseCoord(y, true);
                        if (img && img.complete && img.naturalWidth > 0 && this.isVisible(posX, posY, WEBP_SIZE, WEBP_SIZE)) {
                            const pixelPerfectPosX = Math.round(posX * pixelRatio) / pixelRatio;
                            const pixelPerfectPosY = Math.round(posY * pixelRatio) / pixelRatio;
                            this.ctx.imageSmoothingEnabled = false;
                            this.ctx.drawImage(img, pixelPerfectPosX, pixelPerfectPosY, WEBP_SIZE, WEBP_SIZE);
                            webpCount++;
                            console.log(`WebP ${key}: posX=${pixelPerfectPosX}, posY=${pixelPerfectPosY}`);
                        }
                    });
                }

                let pngCount = 0;
                tiles.forEach(key => {
                    const [x, y] = key.split(',');
                    const img = this.images.png.get(key);
                    const posX = parseCoord(x, false);
                    const posY = parseCoord(y, false);
                    if (img && img.complete && img.naturalWidth > 0 && this.isVisible(posX, posY, PNG_SIZE, PNG_SIZE)) {
                        const pixelPerfectPosX = Math.round(posX * pixelRatio) / pixelRatio;
                        const pixelPerfectPosY = Math.round(posY * pixelRatio) / pixelRatio;
                        this.ctx.imageSmoothingEnabled = false;
                        this.ctx.drawImage(img, pixelPerfectPosX, pixelPerfectPosY, PNG_SIZE, PNG_SIZE);
                        pngCount++;
                        console.log(`PNG ${key}: posX=${pixelPerfectPosX}, posY=${pixelPerfectPosY}`);
                    }
                });

                if (this.polygons && this.polygons.length > 0) {
                    this.polygons.forEach((polygon, index) => {
                        if (this.visibleCategories[polygon.category] && polygon.points && polygon.points.length > 0) {
                            const { points, lineColor, fillColor, closePath, name } = polygon;
                            this.ctx.beginPath();
                            points.forEach((p, i) => {
                                const [x, z] = p;
                                if (i === 0) {
                                    this.ctx.moveTo(x, z);
                                } else {
                                    this.ctx.lineTo(x, z);
                                }
                            });
                            if (closePath) this.ctx.closePath();
                            this.ctx.fillStyle = fillColor;
                            this.ctx.fill();
                            this.ctx.strokeStyle = lineColor;
                            this.ctx.lineWidth = 2 / this.zoom;
                            this.ctx.stroke();

                            if (name) {
                                const [centerX, centerZ] = calculateCentroid(points);
                                this.ctx.font = `${12 / this.zoom}px Arial`;
                                this.ctx.fillStyle = 'white';
                                this.ctx.strokeStyle = 'black';
                                this.ctx.lineWidth = 0.5 / this.zoom;
                                this.ctx.textAlign = 'center';
                                this.ctx.textBaseline = 'middle';
                                this.ctx.strokeText(name, centerX, centerZ);
                                this.ctx.fillText(name, centerX, centerZ);
                            }

                            console.log(`Drawing polygon ${index}: ${points.length} points, lineColor=${lineColor}, fillColor=${fillColor}, closePath=${closePath}, name=${name}, category=${polygon.category}`);
                        }
                    });
                }

                this.ctx.restore();

                const renderTime = performance.now() - renderStart;
                console.log(`Rendered ${webpCount} WebP, ${pngCount} PNG, Render time: ${renderTime.toFixed(2)}ms`);

                requestAnimationFrame(() => this.render());
            }
        }

        const tileMap = new TileMap(document.getElementById('map-container'));
    </script>
</body>
</html>