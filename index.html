<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa z Warstwami PNG i WebP</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000;
        }
        #map-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            background-color: #000;
        }
        #map {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: center center;
            will-change: transform;
        }
        .tile {
            position: absolute;
            image-rendering: pixelated; /* Ostrość pikseli */
            image-rendering: -webkit-crisp-edges; /* Dla starszych przeglądarek */
            image-rendering: -moz-crisp-edges; /* Dla Firefoksa */
        }
        #zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        #zoom-controls button {
            display: block;
            margin: 5px;
            padding: 10px;
            font-size: 20px;
            background-color: #444;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #zoom-controls button:hover {
            background-color: #666;
        }
        #toggle-webp {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 10;
            padding: 10px;
            font-size: 20px;
            background-color: #444;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #toggle-webp:hover {
            background-color: #666;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <div id="map"></div>
    </div>
    <div id="zoom-controls">
        <button id="zoom-in">+</button>
        <button id="zoom-out">-</button>
    </div>
    <button id="toggle-webp">🔒</button>

    <script>
        const PNG_SIZE = 2000;
        const WEBP_SIZE = 7612;
        const imagePath = 'kafelki/';
        const tiles = ['0,0', '0,-0', '-0,0', '-0,-0'];
        const minZoom = 0.1;
        const maxZoom = 5;

        // Mapowanie stringowych współrzędnych na numeryczne pozycje
        function parseCoord(str, isWebP = false) {
            const size = isWebP ? WEBP_SIZE : PNG_SIZE;
            if (str === '0') return 0;
            if (str === '-0') return -size;
            return parseInt(str, 10) > 0 ? parseInt(str, 10) * size : (parseInt(str, 10) - 1) * size;
        }

        // Generowanie klucza dla kafelka
        function getTileKey(x, y) {
            return `${x},${y}`;
        }

        class TileMap {
            constructor(container) {
                this.container = container;
                this.mapElement = document.getElementById('map');
                this.tiles = { png: new Map(), webp: new Map() }; // Cache kafelków PNG i WebP
                this.loadWebPEnabled = false; // Domyślnie wyłączone WebP
                this.zoom = 1;
                this.posX = 0;
                this.posY = 0;
                this.dragging = false;
                this.startX = 0;
                this.startY = 0;

                // Ustawiamy pozycję początkową
                this.centerOnStyk();

                // Przycisk przełączania WebP
                this.toggleButton = document.getElementById('toggle-webp');
                this.toggleButton.addEventListener('click', () => this.toggleWebP());

                // Inicjalizacja zdarzeń
                this.setupEvents();

                // Opóźnione renderowanie
                setTimeout(() => this.render(), 0);
            }

            centerOnStyk() {
                this.posX = window.innerWidth / 2;
                this.posY = window.innerHeight / 2;
            }

            setupEvents() {
                const zoomInBtn = document.getElementById('zoom-in');
                const zoomOutBtn = document.getElementById('zoom-out');

                zoomInBtn.addEventListener('click', () => this.setZoom(this.zoom + 0.1));

                zoomOutBtn.addEventListener('click', () => this.setZoom(this.zoom - 0.1));

                this.container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY < 0 ? 0.1 : -0.1;
                    const rect = this.container.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    this.setZoom(this.zoom + delta, mouseX, mouseY);
                });

                this.container.addEventListener('mousedown', (e) => {
                    this.dragging = true;
                    this.startX = e.clientX - this.posX;
                    this.startY = e.clientY - this.posY;
                    this.container.style.cursor = 'grabbing';
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.dragging) {
                        this.posX = e.clientX - this.startX;
                        this.posY = e.clientY - this.startY;
                        this.clampPosition();
                        this.render();
                    }
                });

                document.addEventListener('mouseup', () => {
                    this.dragging = false;
                    this.container.style.cursor = 'grab';
                });

                window.addEventListener('resize', () => this.render());
            }

            setZoom(newZoom, centerX = window.innerWidth / 2, centerY = window.innerHeight / 2) {
                // Zaokrąglij zoom dla ostrości
                newZoom = Math.round(newZoom * 10) / 10; // Do 1 miejsca po przecinku
                newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
                const dx = (centerX - this.posX) / this.zoom;
                const dy = (centerY - this.posY) / this.zoom;
                this.zoom = newZoom;
                this.posX = centerX - dx * this.zoom;
                this.posY = centerY - dy * this.zoom;
                this.clampPosition();
                this.render();
            }

            getMapBounds() {
                let minX = 0, maxX = 0, minY = 0, maxY = 0;
                tiles.forEach(key => {
                    const [x, y] = key.split(',');
                    const posX = parseCoord(x, this.loadWebPEnabled);
                    const posY = parseCoord(y, this.loadWebPEnabled);
                    const size = this.loadWebPEnabled ? WEBP_SIZE : PNG_SIZE;
                    minX = Math.min(minX, posX);
                    maxX = Math.max(maxX, posX + size);
                    minY = Math.min(minY, posY);
                    maxY = Math.max(maxY, posY + size);
                });
                return { minX, maxX, minY, maxY };
            }

            clampPosition() {
                const { minX, maxX, minY, maxY } = this.getMapBounds();
                const viewWidth = window.innerWidth / this.zoom;
                const viewHeight = window.innerHeight / this.zoom;

                // Oblicz granice, aby co najmniej 1 px mapy był widoczny
                const minPosX = -(maxX * this.zoom - 1);
                const maxPosX = window.innerWidth - (minX * this.zoom + 1);
                const minPosY = -(maxY * this.zoom - 1);
                const maxPosY = window.innerHeight - (minY * this.zoom + 1);

                this.posX = Math.max(minPosX, Math.min(maxPosX, this.posX));
                this.posY = Math.max(minPosY, Math.min(maxPosY, this.posY));
            }

            getVisibleTiles(isWebP = false) {
                const size = isWebP ? WEBP_SIZE : PNG_SIZE;
                const viewWidth = window.innerWidth / this.zoom;
                const viewHeight = window.innerHeight / this.zoom;
                const viewLeft = -this.posX / this.zoom;
                const viewRight = viewLeft + viewWidth;
                const viewTop = -this.posY / this.zoom;
                const viewBottom = viewTop + viewHeight;

                return tiles.filter(key => {
                    const [x, y] = key.split(',');
                    const posX = parseCoord(x, isWebP);
                    const posY = parseCoord(y, isWebP);
                    return posX < viewRight && posX + size > viewLeft && posY < viewBottom && posY + size > viewTop;
                });
            }

            loadWebP() {
                if (this.loadWebPEnabled) {
                    // Ładuj WebP sekwencyjnie
                    const loadWebPSequentially = (index = 0) => {
                        if (index >= tiles.length) {
                            this.render();
                            return;
                        }
                        const key = tiles[index];
                        const [x, y] = key.split(',');
                        const imageUrl = `${imagePath}${key}.webp`;
                        const tile = document.createElement('img');
                        tile.className = 'tile';
                        tile.style.width = `${WEBP_SIZE}px`;
                        tile.style.height = `${WEBP_SIZE}px`;
                        tile.src = imageUrl;
                        tile.onload = () => {
                            this.tiles.webp.set(key, tile);
                            loadWebPSequentially(index + 1); // Ładuj kolejny
                        };
                        tile.onerror = () => {
                            console.error(`Nie udało się załadować ${imageUrl}`);
                            tile.remove();
                            this.tiles.webp.delete(key);
                            loadWebPSequentially(index + 1); // Kontynuuj mimo błędu
                        };
                        const posX = parseCoord(x, true);
                        const posY = parseCoord(y, true);
                        tile.style.left = `${posX}px`;
                        tile.style.top = `${posY}px`;
                        this.mapElement.appendChild(tile);
                        this.tiles.webp.set(key, tile);
                    };
                    loadWebPSequentially();
                }
            }

            toggleWebP() {
                if (!this.loadWebPEnabled) {
                    const confirmLoad = confirm("Włączenie tej funkcji pozwoli wyświetlić całą mapę, ale strona będzie bardzo zasoborzerna");
                    if (confirmLoad) {
                        this.loadWebPEnabled = true;
                        this.toggleButton.textContent = '🔓';
                        this.loadWebP();
                    }
                } else {
                    this.loadWebPEnabled = false;
                    this.toggleButton.textContent = '🔒';
                    // Czyść WebP z pamięci
                    this.tiles.webp.forEach(tile => {
                        tile.src = '';
                        tile.remove();
                    });
                    this.tiles.webp.clear();
                    this.render();
                    // Sugeruj garbage collection
                    if (window.gc) window.gc();
                }
            }

            render() {
                this.mapElement.style.transform = `translate(${this.posX}px, ${this.posY}px) scale(${this.zoom})`;

                const visiblePNGTiles = this.getVisibleTiles(false);
                const visibleWebPTiles = this.loadWebPEnabled ? this.getVisibleTiles(true) : [];
                const currentPNGKeys = new Set();
                const currentWebPKeys = new Set();

                // Rysuj PNG
                let pngCount = 0;
                visiblePNGTiles.forEach(key => {
                    const [x, y] = key.split(',');
                    currentPNGKeys.add(key);
                    if (!this.tiles.png.has(key)) {
                        const imageUrl = `${imagePath}${key}.png`;
                        const tile = document.createElement('img');
                        tile.className = 'tile';
                        tile.style.width = `${PNG_SIZE}px`;
                        tile.style.height = `${PNG_SIZE}px`;
                        tile.src = imageUrl;
                        tile.onload = () => {
                            this.render(); // Odśwież po załadowaniu
                        };
                        tile.onerror = () => {
                            console.error(`Nie udało się załadować ${imageUrl}`);
                            tile.remove();
                            this.tiles.png.delete(key);
                        };
                        const posX = parseCoord(x, false);
                        const posY = parseCoord(y, false);
                        tile.style.left = `${posX}px`;
                        tile.style.top = `${posY}px`;
                        console.log(`PNG ${key}: left=${posX}px, top=${posY}px`);
                        this.mapElement.appendChild(tile);
                        this.tiles.png.set(key, tile);
                    }
                    pngCount++;
                });

                // Rysuj WebP
                let webpCount = 0;
                if (this.loadWebPEnabled) {
                    visibleWebPTiles.forEach(key => {
                        const [x, y] = key.split(',');
                        currentWebPKeys.add(key);
                        if (!this.tiles.webp.has(key)) {
                            // WebP ładowane w loadWebP()
                        } else {
                            const tile = this.tiles.webp.get(key);
                            const posX = parseCoord(x, true);
                            const posY = parseCoord(y, true);
                            tile.style.left = `${posX}px`;
                            tile.style.top = `${posY}px`;
                            console.log(`WebP ${key}: left=${posX}px, top=${posY}px`);
                            if (!tile.parentElement) {
                                this.mapElement.appendChild(tile);
                            }
                        }
                        webpCount++;
                    });
                }

                // Usuń niewidoczne kafelki PNG
                this.tiles.png.forEach((tile, key) => {
                    if (!currentPNGKeys.has(key)) {
                        tile.src = '';
                        tile.remove();
                        this.tiles.png.delete(key);
                    }
                });

                // Usuń niewidoczne kafelki WebP
                this.tiles.webp.forEach((tile, key) => {
                    if (!currentWebPKeys.has(key)) {
                        tile.src = '';
                        tile.remove();
                        this.tiles.webp.delete(key);
                    }
                });

                console.log(`Rendered ${webpCount} WebP, ${pngCount} PNG, Visible WebP: ${visibleWebPTiles.length}, Visible PNG: ${visiblePNGTiles.length}`);
            }
        }

        // Inicjalizacja
        const tileMap = new TileMap(document.getElementById('map-container'));
    </script>
</body>
</html>