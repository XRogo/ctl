<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapa z Kafelkami</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000;
        }
        #map-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            background-color: #000;
        }
        #map {
            position: absolute;
            top: 0;
            left: 0;
        }
        #zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        #zoom-controls button {
            display: block;
            margin: 5px;
            padding: 10px;
            font-size: 20px;
            background-color: #444;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #zoom-controls button:hover {
            background-color: #666;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <canvas id="map"></canvas>
    </div>
    <div id="zoom-controls">
        <button id="zoom-in">+</button>
        <button id="zoom-out">-</button>
    </div>

    <script>
        const TILE_SIZE = 2000;
        const imagePath = 'kafelki/';
        const centralTiles = ['0,0', '0,-0', '-0,0', '-0,-0'];
        const minZoom = 0.1;
        const maxZoom = 5;

        // Mapowanie stringowych współrzędnych na numeryczne pozycje
        function parseCoord(str) {
            if (str === '0') return 0;
            if (str === '-0') return -1;
            return parseInt(str, 10) > 0 ? parseInt(str, 10) : parseInt(str, 10) - 1;
        }

        // Generowanie klucza dla kafelka
        function getTileKey(x, y) {
            return `${x},${y}`;
        }

        // Funkcja do debouncing
        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        class TileMap {
            constructor(container) {
                this.container = container;
                this.canvas = document.getElementById('map');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false; // Ostre piksele
                this.tiles = new Map(); // key => Image
                this.availableTiles = new Set(); // Dostępne klucze kafelków
                this.zoom = 1;
                this.posX = 0;
                this.posY = 0;
                this.dragging = false;
                this.startX = 0;
                this.startY = 0;

                // Ustaw rozmiar canvas
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Ładuj dostępne kafelki na starcie
                this.loadAvailableTiles().then(() => this.preLoadTiles());

                // Ustawiamy pozycję początkową
                this.centerOnStyk();

                // Inicjalizacja zdarzeń
                this.setupEvents();

                // Opóźnione renderowanie
                setTimeout(() => this.render(), 0);
            }

            async loadAvailableTiles() {
                try {
                    const response = await fetch(imagePath);
                    const text = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/html');
                    const links = doc.querySelectorAll('a');
                    links.forEach(a => {
                        const filename = a.textContent.trim();
                        if (filename.endsWith('.png') || filename.endsWith('.webp')) {
                            const key = filename.slice(0, filename.lastIndexOf('.'));
                            this.availableTiles.add(key);
                        }
                    });
                } catch (e) {
                    console.error('Nie udało się pobrać listy plików z folderu kafelki. Używam fallbacku na centralne kafelki.', e);
                    centralTiles.forEach(key => this.availableTiles.add(key));
                }
            }

            preLoadTiles() {
                this.availableTiles.forEach(key => {
                    const [x, y] = key.split(',');
                    this.getTileImage(x, y);
                });
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.render();
            }

            centerOnStyk() {
                this.posX = this.canvas.width / 2;
                this.posY = this.canvas.height / 2;
            }

            setupEvents() {
                const zoomInBtn = document.getElementById('zoom-in');
                const zoomOutBtn = document.getElementById('zoom-out');

                zoomInBtn.addEventListener('click', () => this.setZoom(this.zoom + 0.1));

                zoomOutBtn.addEventListener('click', () => this.setZoom(this.zoom - 0.1));

                this.container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY < 0 ? 0.1 : -0.1;
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    this.setZoom(this.zoom + delta, mouseX, mouseY);
                });

                this.container.addEventListener('mousedown', (e) => {
                    this.dragging = true;
                    this.startX = e.clientX;
                    this.startY = e.clientY;
                    this.container.style.cursor = 'grabbing';
                });

                document.addEventListener('mousemove', debounce((e) => {
                    if (this.dragging) {
                        this.posX += e.clientX - this.startX;
                        this.posY += e.clientY - this.startY;
                        this.startX = e.clientX;
                        this.startY = e.clientY;
                        this.render();
                    }
                }, 16)); // ~60fps

                document.addEventListener('mouseup', () => {
                    this.dragging = false;
                    this.container.style.cursor = 'grab';
                });
            }

            setZoom(newZoom, centerX = this.canvas.width / 2, centerY = this.canvas.height / 2) {
                newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));
                const worldX = (centerX - this.posX) / this.zoom;
                const worldY = (centerY - this.posY) / this.zoom;
                this.zoom = newZoom;
                this.posX = centerX - worldX * this.zoom;
                this.posY = centerY - worldY * this.zoom;
                this.render();
            }

            getVisibleTiles() {
                const viewWidth = this.canvas.width / this.zoom;
                const viewHeight = this.canvas.height / this.zoom;
                const minX = Math.floor((-this.posX / this.zoom - viewWidth / 2) / TILE_SIZE) - 1;
                const maxX = Math.ceil((-this.posX / this.zoom + viewWidth / 2) / TILE_SIZE) + 1;
                const minY = Math.floor((-this.posY / this.zoom - viewHeight / 2) / TILE_SIZE) - 1;
                const maxY = Math.ceil((-this.posY / this.zoom + viewHeight / 2) / TILE_SIZE) + 1;

                const coordValues = [];
                for (let i = Math.max(minX, -5); i <= Math.min(maxX, 5); i++) { // Zakres ±5, dostosuj jeśli więcej kafelków
                    if (i === 0) {
                        coordValues.push('0', '-0');
                    } else {
                        coordValues.push(i.toString());
                    }
                }
                const allVisible = coordValues.flatMap(x => coordValues.map(y => ({ x, y })));
                return allVisible.filter(({x, y}) => this.availableTiles.has(getTileKey(x, y)));
            }

            getTileImage(x, y) {
                const key = getTileKey(x, y);
                if (!this.tiles.has(key)) {
                    const isCentral = centralTiles.includes(key);
                    const ext = isCentral ? 'png' : 'webp';
                    const imageUrl = `${imagePath}${key}.${ext}`;
                    const img = new Image();
                    img.src = imageUrl;
                    img.onerror = () => {
                        if (isCentral) {
                            img.src = `${imagePath}${key}.webp`; // Fallback WebP dla centralnych
                            img.onerror = () => {
                                this.tiles.delete(key);
                                this.availableTiles.delete(key);
                            };
                        } else {
                            this.tiles.delete(key);
                            this.availableTiles.delete(key);
                        }
                    };
                    this.tiles.set(key, img);
                }
                return this.tiles.get(key);
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                this.ctx.translate(this.posX, this.posY);
                this.ctx.scale(this.zoom, this.zoom);

                const visibleTiles = this.getVisibleTiles();

                visibleTiles.forEach(({ x, y }) => {
                    const img = this.getTileImage(x, y);
                    if (img && img.complete && img.naturalWidth > 0) {
                        const posX = parseCoord(x) * TILE_SIZE;
                        const posY = parseCoord(y) * TILE_SIZE;
                        this.ctx.drawImage(img, posX, posY, TILE_SIZE, TILE_SIZE);
                    }
                });

                this.ctx.restore();
            }
        }

        // Inicjalizacja
        const tileMap = new TileMap(document.getElementById('map-container'));
    </script>
</body>
</html>
